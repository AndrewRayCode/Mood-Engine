/* global Leap:true */
// Generated by CoffeeScript 1.7.1
(function() {

var vr = new THREE.VREffect(window.renderer, function( error ) {

var hasVR = !error;

var controller, makeLight, positionLight, releaseLight, dragging,
    oldRotation;

window.controller = controller = new Leap.Controller({
    background: true,
    optimizeHMD: hasVR
});

if( hasVR ) {
    controller.use('transform', {
        quaternion: (new THREE.Quaternion()).setFromEuler(new THREE.Euler(Math.PI * -0.3, 0, Math.PI, 'ZXY')),
        position: new THREE.Vector3(0, 100, 100)
    });
}

controller.use('riggedHand', {
    parent: window.scene,
    camera: window.camera,
    positionScale: 1,
    renderFn: null,
    boneColors: function(boneMesh, leapHand) {
        return {
            hue: 0.6,
            saturation: 0.2,
            lightness: 0.8
        };
    }
});

controller.on('riggedHand.meshAdded', function(handMesh, leapHand) {
    handMesh.castShadow = false;
    handMesh.receiveShadow = false;
});

controller.connect();

makeLight = function(hand) {
    var light, lightVisualizer;
    light = window.lights.pop();
    lightVisualizer = window.lightVisualizers.pop();
    light.intensity = 8;
    hand.data('light', light);
    lightVisualizer.position = light.position;
    lightVisualizer.visible = true;
    return hand.data('lightVisualizer', lightVisualizer);
};

releaseLight = function(hand) {
    var light, lightVisualizer;
    light = hand.data('light');
    if (!light) {
        return;
    }
    light.intensity = 0;
    window.lights.push(light);
    hand.data('light', null);
    lightVisualizer = hand.data('lightVisualizer');
    lightVisualizer.visible = false;
    window.lightVisualizers.push(lightVisualizer);
    return hand.data('lightVisualizer', null);
};

var surfacePoint = window.surfacePoint = new THREE.Mesh(
    new THREE.SphereGeometry(100),
    new THREE.MeshBasicMaterial(0xff0000)
);
//scene.add(surfacePoint);

function pinch( hand ) {
    var handMesh = hand.data('riggedHand.mesh');

    var pos = Leap.vec3.clone(hand.palmPosition);
    var offsetDown = Leap.vec3.clone(hand.palmNormal);
    Leap.vec3.multiply(offsetDown, offsetDown, [50, 50, 50]);
    Leap.vec3.add(pos, pos, offsetDown);
    var offsetForward = Leap.vec3.clone(hand.direction);
    Leap.vec3.multiply(offsetForward, offsetForward, [30, 30, 30]);
    Leap.vec3.add(pos, pos, offsetForward);

    var pinchPosition = handMesh.position.clone();
    // Why did we have this??
    //.add(
        //new THREE.Vector3( pos[0], pos[1], pos[2] )
    //);
    //window.sphere.position.copy( pinchPosition );

    var ray = new THREE.Raycaster( window.camera.position, pinchPosition.sub( window.camera.position ).normalize() );
    var intersects = ray.intersectObject( window.room );

    // if there is one (or more) intersections
    if ( intersects.length ) {

        window.sphere.position.copy( intersects[0].point.clone() );

        surfacePoint.position = intersects[0].point.normalize().multiplyScalar( 100 );

        if( !dragging ) {

            var charmRay = new THREE.Raycaster(
                new THREE.Vector3( 0, 0, 0 ),
                surfacePoint.position.normalize()
            );

            var charmIntersects = charmRay.intersectObjects( window.cubes );

            if( charmIntersects.length ) {
                dragging = charmIntersects[0];
                oldRotation = surfacePoint.position.clone().normalize();
            }
        }

    }

    if( dragging ) {

        var charm = dragging.object.parent,
            charmVectorOld = new THREE.Vector3(
                oldRotation.x,
                oldRotation.y,
                oldRotation.z
            ).normalize(),
            charmVectorNew = surfacePoint.position.clone().normalize();

        var quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            charmVectorNew
        );

        charm.quaternion.copy( quaternion );

        oldRotation = charmVectorNew.clone();
    }
}

var releasePinch = _.debounce( function( hand ) {
    dragging = null;
}, 500 );

var positionHand = function(hand) {
    var handMesh, light, offsetDown, offsetForward, pos;
    handMesh = hand.data('riggedHand.mesh');

    if (hand.pinchStrength > 0.5) {
        if (!hand.data('pinching')) {
            hand.data('pinching', true);
            pinch( hand );
        } else if (hand.data('pinching')) {
            releasePinch( hand );
            hand.data('pinching', false);
        }
    }
};

  controller.on('handLost', releasePinch);

controller.on('hand', positionHand);

});

}).call(this);
